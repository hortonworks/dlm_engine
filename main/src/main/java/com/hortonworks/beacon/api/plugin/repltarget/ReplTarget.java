/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hortonworks.beacon.api.plugin.repltarget;

import com.hortonworks.beacon.api.plugin.ReplEventInfo;
import com.hortonworks.beacon.api.plugin.ReplMessage;
import com.hortonworks.beacon.api.plugin.StatusReporter;
import com.hortonworks.beacon.api.plugin.src.ReplSource;
import com.hortonworks.beacon.client.entity.ReplicationPolicy;
import com.hortonworks.beacon.exceptions.BeaconException;

/**
 * This API describes the plugin interface for plugins on the target side.  These plugins are
 * expected to receive data from Beacon that has been packaged by the
 * {@link ReplSource}.
 *
 * A given ReplTarget handles replicating events of a particular type.  For example, there should be
 * one for Hive, one for HDFS, etc.  In addition to being called for each
 * replication message, the handler will also be called for bootstrapping, failover, and failback.
 *
 * A ReplTarget instance will always be invoked in a separate thread from the main dispatcher to
 * avoid delaying the dispatcher.  ReplTargets themselves may wish to multi-task and thus run work in
 * multiple threads.  To avoid swamping the system it is necessary to bound the total number of
 * threads in the system.  This is achieved by having the ReplTargets always use the passed in
 * ExecutorService rather than spawn new threads themselves.
 */
public abstract class ReplTarget {
    /**
     * This method will be called when a plugin is found by the system and initiated.  It needs to
     * return the message type that this plugin will process.
     * @param info information about the Beacon service, such as the thread pool to use
     * @return Information about this plugin, including what types of messages it handles and the
     * class(es) to use to deserialize them.
     */
    public abstract PluginInfo register(BeaconInfo info);

    // TODO figure out how plugin can fetch replication policies

    /**
     * Handle a replication message.  Beacon does not understand the contents of the ReplMessage
     * and thus does not know if this message is relevant or not.  That is, this event may not be
     * covered by a replication policy that is active on this target.  It is the responsibility
     * of the plugin to determine that.
     * @param msg message containing data regarding the event.  The class of this will be the
     *            class indicated in the PluginInfo returned by {@link #register(BeaconInfo)}.
     * @return Result that indicates whether applying this message was successful.  If
     * success is returned than Beacon will discard the message and pass the next message
     * If RETRIABLE_FAILURE is returned than Beacon will try again, with a backoff to avoid
     * hammering away on the system.  If TERMINAL_FAILURE is declared than the policy will be
     * declared broken and additional messages will not be delivered.
     * @throws BeaconException if something goes wrong
     */
    public abstract HandleResult handleMessage(ReplMessage msg) throws BeaconException;

    /**
     * Initiate a bootstrap operation.  This is called before {@link ReplSource#bootstrap}.  The
     * target plugin is not expected to fetch the data.  This call is made to allow the plugin a
     * chance to set itself up on the target side to prepare the data, in case it needs to do so.
     * @param policy to setup with initial snapshot
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException if something goes wrong
     */
    public abstract ReplMetaMessage boostrap(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                             StatusReporter status) throws BeaconException;

    // TODO - Think about how to extend ReplicationPolicy with component specific information
    // (like database rename for Hive)

    /**
     * Indicate to the plugin that replication has failed for a given policy.  The plugin should
     * respond by ceasing to accept messages for this policy.
     * @param policy for which replication has failed.
     */
    public abstract void markReplicationFailed(ReplicationPolicy policy);

    /**
     * Repair replication that was broken.
     * @param policy that needs repaired
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException if something goes wrong
     */
    public abstract ReplMetaMessage repair(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                           StatusReporter status) throws BeaconException;

    // TODO make repair return an extenable class with info for the source side

    /**
     * Failover a policy, switching the target to primary and ceasing replication.
     * @param policy to failover
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @throws BeaconException if something goes wrong
     */
    public abstract void failover(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                  StatusReporter status) throws BeaconException;

    /**
     * Begin failback of a policy.  This will be called after it has been called on the source.
     * It is expected to begin copying changes since failover
     * from the target to the source.  This will require first running repair backwards and then
     * replicating messages in reverse until {@link #completeFailback} is called.
     * @param policy to failback
     * @param eventInfo information relevant to all messages generated by this event
     * @param fromSource any information the source returned when initiateFailback was called there
     * @param status StatusReporter to use to pass back status info to requester
     * @throws BeaconException if something goes wrong
     */
    public abstract void initiateFailback(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                          ReplMetaMessage fromSource, StatusReporter status)
        throws BeaconException;

    /**
     * Complete failback of a policy.  This expects that the target system has been quiesced and
     * the queue is empty (thus the target and source should now be in sync).  It then switches
     * the target back to read only, the source to read/write, and begins replication moving back
     * from source to target.  This will be called first on the target and then on the source.
     * @param policy to complete failback for
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException
     */
    public abstract ReplMetaMessage completeFailback(ReplicationPolicy policy,
                                                     ReplEventInfo eventInfo,
                                                     StatusReporter status) throws BeaconException;
}
