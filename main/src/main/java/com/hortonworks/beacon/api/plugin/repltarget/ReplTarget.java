/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hortonworks.beacon.api.plugin.repltarget;

import com.hortonworks.beacon.api.plugin.ReplEventInfo;
import com.hortonworks.beacon.api.plugin.ReplMessage;
import com.hortonworks.beacon.api.plugin.ReplMetaMessage;
import com.hortonworks.beacon.api.plugin.StatusReporter;
import com.hortonworks.beacon.api.plugin.src.ReplSource;
import com.hortonworks.beacon.client.entity.ReplicationPolicy;
import com.hortonworks.beacon.exceptions.BeaconException;

/**
 * This API describes the plugin interface for plugins on the target side.  These plugins are
 * expected to receive data from Beacon that has been packaged by the
 * {@link ReplSource}.
 *
 * A given ReplTarget handles replicating events of a particular type.  For example, there should be
 * one for Hive, one for HDFS, etc.  In addition to being called for each
 * replication message, the handler will also be called for bootstrapping, failover, and failback.
 *
 * A ReplTarget instance will always be invoked in a separate thread from the main dispatcher to
 * avoid delaying the dispatcher.  ReplTargets themselves may wish to multi-task and thus run work in
 * multiple threads.  To avoid swamping the system it is necessary to bound the total number of
 * threads in the system.  This is achieved by having the ReplTargets always use the passed in
 * ExecutorService rather than spawn new threads themselves.
 *
 * Beacon does not understand the content of replication messages and thus does not know what
 * replication messages are of interest and what is not.  It does track replication types, and
 * will not give messages from other plugin types to this plugin.  For example, messages
 * generated by HDFS on the source will not be sent to the Hive plugin on the target.  But
 * <u>all</u> Hive messages generated on the source will be given to the target.  It is up to the
 * target to decide whether or not it cares based on the replication policies in effect.
 *
 * Beacon provides each plugin with the set of all replication policies that cover its
 * replication type in the {@link BeaconInfo} object passed as part of {@link #register}.  It is
 * assumed that plugin will take this set and organize in a way that allows them to do efficient
 * look ups rather than needing to compare every message against every policy in the set.  To
 * facilitate this {@link #policyActivated} and {@link #policyDeactivated} are provided.  These
 * will be called whenever a policy is activated or deactivated.  The plugin can then use these
 * to update its cache.  The set of policies passed in BeaconInfo is kept up to date so the
 * plugin can rebuild its cache using that at any time.
 */
public abstract class ReplTarget {
    /**
     * This method will be called when a plugin is found by the system and initiated.  It needs to
     * return the message type that this plugin will process.
     * @param info information about the Beacon service, such as the thread pool to use
     * @return Information about this plugin, including what types of messages it handles and the
     * class(es) to use to deserialize them.
     */
    public abstract PluginInfo register(BeaconInfo info);

    /**
     * Inform the plugin that a replication policy has been made active.  It is up to the plugin to
     * determine whether to track policies and to decide whether it cares about this particular
     * policy.
     * @param policy that is being activated.
     */
    public abstract void policyActivated(ReplicationPolicy policy);

    /**
     * Inform the plugin that a replication policy has been deactivated.
     * @param policy that is being deactivated.
     */
    public abstract void policyDeactivated(ReplicationPolicy policy);

    /**
     * Handle a replication message.  Beacon does not understand the contents of the ReplMessage
     * and thus does not know if this message is relevant or not.  That is, this event may not be
     * covered by a replication policy that is active on this target.  It is the responsibility
     * of the plugin to determine that.
     * @param msg message containing data regarding the event.  The class of this will be the
     *            class indicated in the PluginInfo returned by {@link #register(BeaconInfo)}.
     * @return Result that indicates whether applying this message was successful.  If
     * success is returned than Beacon will discard the message and pass the next message
     * If RETRIABLE_FAILURE is returned than Beacon will try again, with a backoff to avoid
     * hammering away on the system.  If TERMINAL_FAILURE is declared than the policy will be
     * declared broken and additional messages will not be delivered.
     * @throws BeaconException if something goes wrong
     */
    public abstract HandleResult handleMessage(ReplMessage msg) throws BeaconException;

    /**
     * Initiate a bootstrap operation.  This is called before
     * {@link ReplSource#boostrap(ReplicationPolicy, ReplEventInfo, ReplMetaMessage, StatusReporter)}
     * The target plugin is not expected to fetch the data.  This call is made to allow the plugin a
     * chance to set itself up on the target side to prepare the data, in case it needs to do so.
     * @param policy to setup with initial snapshot
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException if something goes wrong
     */
    public abstract ReplMetaMessage boostrap(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                             StatusReporter status) throws BeaconException;

    // TODO - Think about how to extend ReplicationPolicy with component specific information
    // (like database rename for Hive)

    /**
     * Repair replication that was broken.
     * @param policy that needs repaired
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException if something goes wrong
     */
    public abstract ReplMetaMessage repair(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                           StatusReporter status) throws BeaconException;

    // TODO make repair return an extenable class with info for the source side

    /**
     * Failover a policy, switching the target to primary and ceasing replication.
     * @param policy to failover
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @throws BeaconException if something goes wrong
     */
    public abstract void failover(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                  StatusReporter status) throws BeaconException;

    /**
     * Begin failback of a policy.  This will be called after it has been called on the source.
     * It is expected to begin copying changes since failover
     * from the target to the source.  This will require first running repair backwards and then
     * replicating messages in reverse until {@link #completeFailback} is called.
     * @param policy to failback
     * @param eventInfo information relevant to all messages generated by this event
     * @param fromSource any information the source returned when initiateFailback was called there
     * @param status StatusReporter to use to pass back status info to requester
     * @throws BeaconException if something goes wrong
     */
    public abstract void initiateFailback(ReplicationPolicy policy, ReplEventInfo eventInfo,
                                          ReplMetaMessage fromSource, StatusReporter status)
        throws BeaconException;

    /**
     * Complete failback of a policy.  This expects that the target system has been quiesced and
     * the queue is empty (thus the target and source should now be in sync).  It then switches
     * the target back to read only, the source to read/write, and begins replication moving back
     * from source to target.  This will be called first on the target and then on the source.
     * @param policy to complete failback for
     * @param eventInfo information relevant to all messages generated by this event
     * @param status StatusReporter to use to pass back status info to requester
     * @return any information that the target wishes to pass to the plugin on the source.  This
     * can be left null.
     * @throws BeaconException if something goes wrong
     */
    public abstract ReplMetaMessage completeFailback(ReplicationPolicy policy,
                                                     ReplEventInfo eventInfo,
                                                     StatusReporter status) throws BeaconException;
}
